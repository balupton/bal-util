// Generated by CoffeeScript 1.3.3
(function() {
  var balUtilFlow, balUtilModules,
    __slice = [].slice;

  balUtilModules = null;

  balUtilFlow = require(__dirname + '/flow');

  balUtilModules = {
    spawn: function(commands, options, callback) {
      var results, spawn, tasks, _ref;
      _ref = balUtilFlow.extractOptsAndCallback(options, callback), options = _ref[0], callback = _ref[1];
      spawn = require('child_process').spawn;
      results = [];
      options || (options = {});
      tasks = new balUtilFlow.Group(function(err) {
        return callback.apply(callback, [err, results]);
      });
      if (!(commands instanceof Array)) {
        commands = [commands];
      }
      balUtilFlow.each(commands, function(command) {
        return tasks.push(function(complete) {
          var err, pid, stderr, stdout;
          pid = null;
          err = null;
          stdout = '';
          stderr = '';
          if (typeof command === 'string') {
            command = command.split(' ');
          }
          if (command instanceof Array) {
            pid = spawn(command[0], command.slice(1), options);
          } else {
            pid = spawn(command.command, command.args || [], command.options || options);
          }
          pid.stdout.on('data', function(data) {
            var dataStr;
            dataStr = data.toString();
            if (options.output) {
              process.stdout.write(dataStr);
            }
            return stdout += dataStr;
          });
          pid.stderr.on('data', function(data) {
            var dataStr;
            dataStr = data.toString();
            if (options.output) {
              process.stderr.write(dataStr);
            }
            return stderr += dataStr;
          });
          return pid.on('exit', function(code, signal) {
            err = null;
            if (code === 1) {
              err = new Error(stderr || 'exited with failure code');
            }
            results.push([err, stdout, stderr, code, signal]);
            return complete(err);
          });
        });
      });
      tasks.sync();
      return this;
    },
    exec: function(commands, options, callback) {
      var exec, results, tasks, _ref;
      _ref = balUtilFlow.extractOptsAndCallback(options, callback), options = _ref[0], callback = _ref[1];
      exec = require('child_process').exec;
      results = [];
      tasks = new balUtilFlow.Group(function(err) {
        return callback.apply(callback, [err, results]);
      });
      if (!(commands instanceof Array)) {
        commands = [commands];
      }
      balUtilFlow.each(commands, function(command) {
        return tasks.push(function(complete) {
          return exec(command, options, function() {
            var args, err;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            err = args[0] || null;
            results.push(args);
            return complete(err);
          });
        });
      });
      tasks.sync();
      return this;
    },
    getGitPath: function(next) {
      var foundGitPath, pathUtil, possibleGitPaths, tasks;
      pathUtil = require('path');
      foundGitPath = null;
      possibleGitPaths = process.platform.indexOf('win') !== -1 ? ['git', pathUtil.join('%ProgramFiles%', 'Git', 'bin', 'git'), pathUtil.join('%ProgramFiles(x86)%', 'Git', 'bin', 'git')] : ['git', '/usr/local/bin/git', '/usr/bin/git'];
      tasks = new balUtilFlow.Group(function(err) {
        return next(err, foundGitPath);
      });
      balUtilFlow.each(possibleGitPaths, function(possibleGitPath) {
        return tasks.push(function(complete) {
          return balUtilModules.spawn([[possibleGitPath, '--version']], function(err, results) {
            if (!err) {
              foundGitPath = possibleGitPath;
              return tasks.exit();
            } else {
              return complete();
            }
          });
        });
      });
      tasks.sync();
      return this;
    },
    initGitRepo: function(opts) {
      var branch, commands, gitPath, logger, next, output, path, remote, url;
      if (opts == null) {
        opts = {};
      }
      path = opts.path, remote = opts.remote, url = opts.url, branch = opts.branch, gitPath = opts.gitPath, logger = opts.logger, output = opts.output, next = opts.next;
      gitPath || (gitPath = 'git');
      commands = [
        {
          command: gitPath,
          args: ['init']
        }, {
          command: gitPath,
          args: ['remote', 'add', remote, url]
        }, {
          command: gitPath,
          args: ['fetch', remote]
        }, {
          command: gitPath,
          args: ['pull', remote, branch]
        }, {
          command: gitPath,
          args: ['submodule', 'init']
        }, {
          command: gitPath,
          args: ['submodule', 'update', '--recursive']
        }
      ];
      if (logger) {
        logger.log('debug', "Initializing git repo with url [" + url + "] on directory [" + path + "]");
      }
      return balUtilModules.spawn(commands, {
        cwd: path,
        output: output
      }, function(err, results) {
        if (err) {
          return next(err, results);
        }
        if (logger) {
          logger.log('debug', "Initialized git repo with url [" + url + "] on directory [" + path + "]");
        }
        return next(err, results);
      });
    },
    initNodeModules: function(opts) {
      var command, force, logger, next, nodeModulesPath, nodePath, npmPath, output, packageJsonPath, path, pathUtil;
      if (opts == null) {
        opts = {};
      }
      pathUtil = require('path');
      path = opts.path, nodePath = opts.nodePath, npmPath = opts.npmPath, force = opts.force, logger = opts.logger, output = opts.output, next = opts.next;
      npmPath || (npmPath = 'npm');
      packageJsonPath = pathUtil.join(path, 'package.json');
      nodeModulesPath = pathUtil.join(path, 'node_modules');
      if (force === false && pathUtil.existsSync(nodeModulesPath)) {
        return next();
      }
      if (!pathUtil.existsSync(packageJsonPath)) {
        return next();
      }
      if (nodePath) {
        command = {
          command: nodePath,
          args: [npmPath, 'install']
        };
      } else {
        command = {
          command: npmPath,
          args: ['install']
        };
      }
      if (logger) {
        logger.log('debug', "Initializing node modules\non:   " + dirPath + "\nwith:", command);
      }
      balUtilModules.spawn(command, {
        cwd: path,
        output: output
      }, function(err, results) {
        if (logger) {
          if (logger) {
            logger.log('debug', "Initialized node modules\non:   " + dirPath + "\nwith:", command);
          }
        }
        return next(err, results);
      });
      return this;
    }
  };

  module.exports = balUtilModules;

}).call(this);
